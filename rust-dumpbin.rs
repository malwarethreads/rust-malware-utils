use std::env;
use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use std::string::String;

fn main() {
  let args: Vec<String> = env::args().collect();

  let path = Path::new(&args[1]);
  let display = path.display();
  let file = match File::open(&path) {
    Err(why) => panic!("couldn't open {}: {}", 
                       display, 
                       Error::description(&why)),
    Ok(file) => file,
  };

  // Printable ASCII range from 0x20 (32) to 0x7E (126)

  println!("------------------+-------------------------+-------------------------+------------------");
  println!("      OFFSET      | 00 01 02 03 04 05 06 07   08 09 0A 0B 0C 0D 0E 0F |  ASCII (7-bit)   ");
  println!("------------------+-------------------------+-------------------------+------------------");

  let mut line: u32 = 0;
  let mut i:    usize = 0;
  let mut buf: [char; 16] = [' '; 16];

  for byte in file.bytes() {
    if i % 16 == 0 {
      print!(" {:016X} | ", line);
    }

    let b = byte.unwrap() as char;
    let idx = i % 16;
    buf[idx] = b;

    line += 1;
    print!("{:02X} ", b as u8);
    i += 1;
    if i % 8 == 0 {
      print!("| ");
    }
    if i % 16 == 0 {
      for c in 0..16 {
        if buf[c] >= ' ' && buf[c] <= '~' {
          print!("{}", buf[c] as char);
        } else {
          print!(".");
        }
      }
      println!("");
    }
  }

  // flush remaining bytes from last line
  while i % 16 != 0 {
    print!("   "); // 3 spaces (2 for byte and 1 for spacing)
    buf[i % 16] = ' ';
    i += 1;
    if i % 8 == 0 {
      print!("| ");
    }
    if i % 16 == 0 {
      for c in 0..16 {
        if buf[c] >= ' ' && buf[c] <= '~' {
          print!("{}", buf[c] as char);
        } else {
          print!(".");
        }
      }
      println!("");
    }
  }

}